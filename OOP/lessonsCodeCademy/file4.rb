=begin

Наследование

Следите за своими действиями
Наследование - сложная концепция, поэтому давайте рассмотрим ее шаг за шагом.

Наследование - это процесс, в результате которого один класс приобретает атрибуты и методы другого, и используется для
выражения отношения "есть - есть". Например, мультяшная лиса - это мультяшное млекопитающее, поэтому класс CartoonFox
может наследоваться от класса CartoonMammal.

Однако волшебник - это не эльф, поэтому он не должен наследоваться от класса Elf (даже если у них много общих магических
атрибутов и методов). Вместо этого и Wizard, и Elf могут наследоваться от одного и того же класса MagicalBeing.

=end

=begin
Пример:

Мы определили класс ApplicationError, а также класс SuperBadError, который наследуется
от ApplicationError. Обратите внимание, что мы не определяем метод display_error в теле SuperBadError, но он все равно
будет иметь доступ к этому методу через наследование. Нажмите кнопку Run, чтобы убедиться в этом!

=end

class ApplicationError
  def display_error
    puts "Error! Error!"
  end
end

class SuperBadError < ApplicationError
end

err = SuperBadError.new
err.display_error

puts '----------------------------------------------------'

=begin
Синтаксис наследования
В Ruby наследование работает следующим образом:

class DerivedClass < BaseClass
  # Некоторые вещи!
end

Производный класс - это новый класс, который вы создаете, а базовый класс - это класс, от которого наследуется этот новый
класс. Слово "<" можно читать как "наследует от".

=end

class Application
  def initialize(name)
    @name = name
  end
end


class MyApp < Application
  
end

=begin

Переопределение!
Иногда требуется, чтобы один класс, наследующий от другого, не только перенимал методы и атрибуты своего родителя,
но и переопределял один или несколько из них.

Например, у вас может быть класс Email, который наследуется от Message. Оба класса могут иметь метод send,
который отправляет сообщения, но в версии для электронной почты может потребоваться определять действительные адреса
электронной почты и использовать множество протоколов электронной почты, о которых Message ничего не знает.
Вместо того чтобы добавлять метод send_email в производный класс и наследовать метод отправки, который вы никогда
не будете использовать, можно просто явно создать метод отправки в классе Email и поручить ему всю работу по отправке
электронной почты.

Эта новая версия send будет переопределять (то есть заменять) унаследованную версию для любого объекта, являющегося
экземпляром Email.

Пример:

Попробуем рассмотреть более занимательный (хотя и менее реалистичный) пример. Создайте новый класс Dragon,
который наследуется от Creature. Дайте своему производному классу метод fight, который переопределяет метод Creature;
вместо возврата "Punch to the chops!" он должен возвращать "Breathes fire!".

=end

class Creature
  def initialize(name)
    @name = name
  end
  
  def fight
    return "Punch to the chops!"
  end
end

# Add your code below!

class Dragon < Creature
  def fight
    return "Breathes fire!"
  end
end

# 14