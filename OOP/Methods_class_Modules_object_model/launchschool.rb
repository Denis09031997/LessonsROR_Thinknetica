# Мини-книга по OOP в Ruby (часть про методы и переменные класса): launchschool.com

=begin
Методы класса
До сих пор все созданные нами методы были методами экземпляра. То есть это методы, относящиеся к экземпляру или
объекту класса. Существуют также методы уровня класса, называемые методами класса. Методы класса - это методы,
которые мы можем вызывать непосредственно в самом классе, без необходимости инстанцировать какие-либо объекты.

При определении метода класса мы добавляем к имени метода зарезервированное слово self., например, так:


def self.what_am_i         # Class method definition
  "I'm a GoodDog class!"
end

Тогда при вызове метода класса мы используем имя класса GoodDog, за которым следует имя метода,
даже не инстанцируя никаких объектов, как это сделано здесь:

GoodDog.what_am_i          # => I'm a GoodDog class!

Зачем нам для этого нужен метод класса? Этот пример немного надуман, но методы класса - это место, куда мы помещаем
функциональность, не относящуюся к отдельным объектам. Объекты содержат состояния, и если у нас есть метод, которому
не нужно работать с состояниями, то мы можем просто использовать метод класса, как в нашем простом примере
=end

#  ПЕРЕМЕННЫЕ КЛАССА

=begin
Переменные класса
Подобно тому, как переменные экземпляра фиксируют информацию, относящуюся к конкретным экземплярам классов 
(т.е. объектам), мы можем создавать переменные для всего класса, которые соответствующим образом называются
переменными класса. Переменные класса создаются с помощью двух символов @ следующим образом: @@. 
Создадим переменную класса и метод класса для ее просмотра.
=end

class GoodDog
  @@number_of_dogs = 0

  def initialize
    @@number_of_dogs += 1
  end

  def self.total_number_of_dogs
    @@number_of_dogs
  end
end

puts GoodDog.total_number_of_dogs
dog1 = GoodDog.new
dog2 = GoodDog.new

puts GoodDog.total_number_of_dogs

=begin
У нас есть переменная класса @@number_of_dogs, которую мы инициализируем в 0. Затем в нашем конструкторе 
(метод initialize) мы увеличиваем это число на 1. Помните, что initialize вызывается каждый раз, когда мы 
инстанцируем новый объект с помощью метода new. Это также демонстрирует, что мы можем обращаться к переменным класса
из метода экземпляра (initialize - это метод экземпляра). Наконец, мы просто возвращаем значение переменной класса 
в методе класса self.total_number_of_dogs. Это пример использования переменной класса и метода класса для отслеживания 
деталей уровня класса, относящихся только к классу, а не к отдельным объектам.

=end


# КОНСТАНТЫ

=begin
При создании классов также могут быть определенные переменные, которые никогда не нужно изменять.
Для этого можно создать так называемые константы. Для определения константы в начале имени переменной
используется заглавная буква. Хотя технически константы должны начинаться только с заглавной буквы, большинство
рубистов делают всю переменную заглавной.

=end

puts '.' * 120

class GoodCat
  CAT_YEARS = 7

  attr_accessor :name, :age

  def initialize(n, a)
    self.name = n
    self.age = a * CAT_YEARS
  end

  def about_cat
    puts "Кота зовут #{name} и он снимался в мультике Том и Джерри."
  end

  def to_s
    "Это кошак #{name} и его возраст = #{age}."
  end
end

tom = GoodCat.new('Tom', 4)
puts tom.age
puts tom.name
tom.about_cat
puts tom # вызываем переопределный to_s
=begin
Здесь мы использовали константу CAT_YEARS для вычисления возраста в собачьих годах при создании объекта tom.
Обратите внимание, что мы использовали методы setter в методе initialize для инициализации переменных экземпляра
@name и @age, переданных нам методом attr_accessor. Затем мы использовали метод-геттер age для получения значения
из объекта.

CAT_YEARS - это переменная, которая никогда не изменится по какой-либо причине, поэтому мы используем константу.
Присвоить константам новое значение можно, но Ruby выдаст предупреждение.

=end


# Метод to_s

=begin
Метод экземпляра to_s встроен в каждый класс в Ruby. Фактически, мы используем его все время. Например,
предположим, что у нас есть класс GoodCat, описанный выше, и объект tom, также описанный выше.

=end

puts tom

=begin
Здесь происходит то, что метод puts автоматически вызывает to_s на своем аргументе, которым в данном случае является
объект tom. Другими словами, puts tom эквивалентен puts tom.to_s. Причина, по которой мы получаем именно
такой результат, кроется в методе to_s в Ruby. По умолчанию метод to_s возвращает имя класса объекта и кодировку 
идентификатора объекта.

=end

# Примечание: метод puts вызывает to_s для любого аргумента, не являющегося массивом. Для массива он записывает
# в отдельных строках результат вызова to_s для каждого элемента массива.

# Чтобы проверить это, мы можем добавить собственный метод to_s в наш класс GoodCat, переопределив стандартный to_s,
# поставляемый с Ruby.

=begin
И да, это работает! Мы смогли изменить вывод, переопределив метод экземпляра to_s.

Существует еще один метод p, очень похожий на puts, только он не вызывает to_s для своего аргумента, 
а вызывает другой встроенный метод экземпляра Ruby, называемый inspect. Метод inspect очень полезен для
отладки, поэтому мы не хотим переопределять его.

Помимо автоматического вызова при использовании puts, еще одним важным свойством метода to_s является то,
что он также автоматически вызывается при интерполяции строк.

Таким образом, метод to_s вызывается автоматически на объекте, когда мы используем его с помощью puts
или при использовании строковой интерполяции. На данный момент этот факт может показаться тривиальным,
но знание того, когда вызывается to_s, поможет нам понять, как читать и писать более качественный ОО-код.


=end

p tom # эквивалентно puts tom.inspect.
puts '-' * 120

=begin
Как показано выше, в классе можно настроить поведение #to_s. Если не настраивать #to_s, то Ruby ищет в цепочке 
наследования другую версию #to_s, которой обычно является Object#to_s.

При переопределении (настройке) #to_s для использования в пользовательском классе необходимо помнить, что Ruby ожидает,
что #to_s всегда будет возвращать строку. Если он не возвращает строку, то #to_s не будет работать так, как ожидается,
в местах, где #to_s неявно вызывается, например, в puts или интерполяции. Вместо печати (или вставки) значения,
возвращаемого #to_s, Ruby будет игнорировать нестроковое значение и искать в цепочке наследования другую версию #to_s,
возвращающую строку. В большинстве случаев вместо этого будет использовано значение, возвращаемое объектом #to_s.
Например:

=end
class Foo
  def to_s
    42
  end
end

foo = Foo.new
puts foo             # Prints #<Foo:0x0000000100760ec0>
puts "foo is #{foo}" # Prints: foo is #<Foo:0x0000000100760ec0>
puts '.' * 100

# Если заменить 42 на строку, то код будет работать так, как нужно:

class Foo2
  def to_s
    '42'
  end
end

foo2 = Foo2.new
puts foo2
puts "foo is #{foo2}"

=begin
Следует также отметить, что переопределение #to_s работает только для объектов того типа, для которого определен
настроенный метод #to_s. В частности, если у вас есть объект Bar с именем bar, у которого есть атрибут xyz и метод
Bar#to_s, то в функции puts bar.xyz не будет использоваться настроенный #to_s. Значение, возвращаемое xyz,
не является объектом Bar, поэтому метод Bar#to_s к нему не применяется:

=end

class Bar
  attr_reader :xyz
  def initialize
    @xyz = { a: 1, b: 2 }
  end

  def to_s
    'I am a Bar object!'
  end
end

bar = Bar.new
puts bar       # Prints I am a Bar object!
puts bar.xyz   # Prints {:a=>1, :b=>2}

puts '_' * 120

=begin
Мы уже говорили о self, но давайте попробуем погрузиться немного глубже, чтобы вы могли понять, что именно такое self
и как понять, на что оно ссылается. self может ссылаться на разные вещи в зависимости от того, где оно используется.

Например, до сих пор мы видели два явных случая использования self:

Использование self при вызове методов setter из класса. В нашем предыдущем примере мы показали, что self был необходим
для корректной работы метода change_info. Мы должны были использовать self, чтобы Ruby мог отличить инициализацию
локальной переменной от вызова метода setter.

Используйте self в определениях методов класса.

Давайте поиграем с self, чтобы понять, почему эти два правила работают. Возьмем следующий код:

Это наш стандартный класс GoodDog2, и мы используем self всякий раз, когда вызываем метод экземпляра из класса.
Мы знаем правило использования self, но что на самом деле представляет собой self? Давайте добавим еще один метод
экземпляра, чтобы выяснить это.


=end

class GoodDog2
  attr_accessor :name, :height, :weight

  def initialize(n, h, w)
    self.name   = n
    self.height = h
    self.weight = w
  end

  def change_info(n, h, w)
    self.name   = n
    self.height = h
    self.weight = w
  end

  def info
    "#{self.name} weighs #{self.weight} and is #{self.height} tall."
  end

  def what_is_self
    self
  end

  puts self
end

# Теперь мы можем инстанцировать новый объект GoodDog2.

gary = GoodDog2.new('Gary', '12 inches', '10 lbs')
p gary.what_is_self
puts gary.info

# Это интересно. Изнутри класса, когда метод экземпляра использует self, он ссылается на вызывающий объект.
# В данном случае это объект sparky. Поэтому изнутри метода change_info вызов self.name= действует так же,
# как и вызов sparky.name= извне класса (внутри класса, правда, вызвать sparky.name= нельзя, так как он не находится
# в области видимости). Теперь мы понимаем, почему использование self для вызова методов экземпляра изнутри класса
# работает именно так!

# Другое место, где мы используем self, - это при определении методов класса, например, так:

class MyAwesomeClass
  def self.this_is_a_class_method
  end
end


=begin
Когда к определению метода добавляется self, это означает, что он определяет метод класса. О них мы говорили ранее.
нашем примере с методом класса GoodDog мы определили метод класса self.total_number_of_dogs. Этот метод возвращал
значение переменной класса @@number_of_dogs. Как такое возможно? Давайте добавим строку в наш класс GoodDog:

class GoodDog
  # ... rest of code omitted for brevity
  puts self
end
=end

=begin
Если запустить файл good_dog.rb с определением класса GoodDog, то можно увидеть, что GoodDog выводится. 
Таким образом, видно, что использование self внутри класса, но вне метода экземпляра, относится к самому классу. 
Поэтому определение метода с префиксом self - это то же самое, что определение метода на классе. 
То есть def self.a_method эквивалентно def GoodDog.a_method. Вот почему это метод класса; на самом деле он 
определяется на классе. Использование self.a_method, а не ClassName.a_method - это соглашение. 
Она удобна тем, что если в будущем мы переименуем класс, то нам придется изменить только имя класса, 
а не переименовывать все методы класса.

Чтобы было понятно, изнутри класса...

self внутри метода экземпляра ссылается на экземпляр (объект), вызвавший метод - вызывающий объект. 
Поэтому в нашем примере self.weight= - это то же самое, что sparky.weight=.

self, вне метода экземпляра, ссылается на класс и может использоваться для определения методов класса. Поэтому если 
мы определим метод класса name, то def self.name=(n) будет то же самое, что def GoodDog.name=(n).

Таким образом, мы видим, что self - это способ явно указать, на что ссылается наша программа и каковы наши намерения 
в отношении поведения. self изменяется в зависимости от области видимости, в которой он используется, поэтому обратите
внимание на то, находитесь ли вы внутри метода экземпляра или нет. self - сложное понятие для понимания в начале, 
но чем чаще вы будете видеть его использование, тем лучше вы будете понимать объектно-ориентированное программирование. 
Если объяснения не совсем понятны, просто запомните пока эти два правила.
=end

=begin
Резюме
В этой главе было рассмотрено много информации о классах, объектах и ООП. Но вы становитесь гораздо более компетентным 
в языке, поэтому способны усваивать больше и обрабатывать более сложный материал. Вы растете как программист на Ruby. 
Вот тут-то и начинается самое интересное.

В этой главе мы рассмотрели...

Инициализация объектов с помощью метода new
Как переменные экземпляра отслеживают состояние объекта
Как методы attr_* генерируют геттеры и сеттеры
Использование методов экземпляра для выполнения операций над нашими объектами
Использование методов класса для выполнения операций на уровне класса
Присвоение переменных класса, относящихся непосредственно к нашему классу
Присвоение констант, которые никогда не меняются, для выполнения операций в наших классах
Как используется метод to_s и что мы все это время использовали его неявно.
Как и когда использовать self
Если вы никогда раньше не сталкивались с ООП, то эта глава должна была быть очень интересной, поэтому нам 
нужно много практиковаться, чтобы действительно понять ее. Не пропускайте упражнения; ООП - это очень важный 
раздел фундаментальных знаний, которые понадобятся вам для настоящего понимания кода на языке Ruby и таких фреймворков, 
как Rails.

=end

