# Мини-книга по OOP в Ruby (часть про методы и переменные класса): launchschool.com

=begin
Методы класса
До сих пор все созданные нами методы были методами экземпляра. То есть это методы, относящиеся к экземпляру или
объекту класса. Существуют также методы уровня класса, называемые методами класса. Методы класса - это методы,
которые мы можем вызывать непосредственно в самом классе, без необходимости инстанцировать какие-либо объекты.

При определении метода класса мы добавляем к имени метода зарезервированное слово self., например, так:


def self.what_am_i         # Class method definition
  "I'm a GoodDog class!"
end

Тогда при вызове метода класса мы используем имя класса GoodDog, за которым следует имя метода,
даже не инстанцируя никаких объектов, как это сделано здесь:

GoodDog.what_am_i          # => I'm a GoodDog class!

Зачем нам для этого нужен метод класса? Этот пример немного надуман, но методы класса - это место, куда мы помещаем
функциональность, не относящуюся к отдельным объектам. Объекты содержат состояния, и если у нас есть метод, которому
не нужно работать с состояниями, то мы можем просто использовать метод класса, как в нашем простом примере
=end

#  ПЕРЕМЕННЫЕ КЛАССА

=begin
Переменные класса
Подобно тому, как переменные экземпляра фиксируют информацию, относящуюся к конкретным экземплярам классов 
(т.е. объектам), мы можем создавать переменные для всего класса, которые соответствующим образом называются
переменными класса. Переменные класса создаются с помощью двух символов @ следующим образом: @@. 
Создадим переменную класса и метод класса для ее просмотра.
=end

class GoodDog
  @@number_of_dogs = 0

  def initialize
    @@number_of_dogs += 1
  end

  def self.total_number_of_dogs
    @@number_of_dogs
  end
end

puts GoodDog.total_number_of_dogs
dog1 = GoodDog.new
dog2 = GoodDog.new

puts GoodDog.total_number_of_dogs

=begin
У нас есть переменная класса @@number_of_dogs, которую мы инициализируем в 0. Затем в нашем конструкторе 
(метод initialize) мы увеличиваем это число на 1. Помните, что initialize вызывается каждый раз, когда мы 
инстанцируем новый объект с помощью метода new. Это также демонстрирует, что мы можем обращаться к переменным класса
из метода экземпляра (initialize - это метод экземпляра). Наконец, мы просто возвращаем значение переменной класса 
в методе класса self.total_number_of_dogs. Это пример использования переменной класса и метода класса для отслеживания 
деталей уровня класса, относящихся только к классу, а не к отдельным объектам.

=end


# КОНСТАНТЫ

=begin
При создании классов также могут быть определенные переменные, которые никогда не нужно изменять. 
Для этого можно создать так называемые константы. Для определения константы в начале имени переменной
используется заглавная буква. Хотя технически константы должны начинаться только с заглавной буквы, большинство
рубистов делают всю переменную заглавной.

=end

puts '.' * 120

class GoodCat
  CAT_YEARS = 7

  attr_accessor :name, :age

  def initialize(n, a)
    self.name = n
    self.age = a * CAT_YEARS
  end

  def about_cat
    puts "Кота зовут #{name} и он снимался в мультике Том и Джерри."
  end

  def to_s
    "Это кошак #{name} и его возраст = #{age}."
  end
end

tom = GoodCat.new('Tom', 4)
puts tom.age
puts tom.name
tom.about_cat
puts tom # вызываем переопределный to_s
=begin
Здесь мы использовали константу CAT_YEARS для вычисления возраста в собачьих годах при создании объекта tom.
Обратите внимание, что мы использовали методы setter в методе initialize для инициализации переменных экземпляра
@name и @age, переданных нам методом attr_accessor. Затем мы использовали метод-геттер age для получения значения
из объекта.

CAT_YEARS - это переменная, которая никогда не изменится по какой-либо причине, поэтому мы используем константу.
Присвоить константам новое значение можно, но Ruby выдаст предупреждение.

=end


# Метод to_s

=begin
Метод экземпляра to_s встроен в каждый класс в Ruby. Фактически, мы используем его все время. Например,
предположим, что у нас есть класс GoodCat, описанный выше, и объект tom, также описанный выше.

=end

puts tom

=begin
Здесь происходит то, что метод puts автоматически вызывает to_s на своем аргументе, которым в данном случае является
объект tom. Другими словами, puts tom эквивалентен puts tom.to_s. Причина, по которой мы получаем именно
такой результат, кроется в методе to_s в Ruby. По умолчанию метод to_s возвращает имя класса объекта и кодировку 
идентификатора объекта.

=end

# Примечание: метод puts вызывает to_s для любого аргумента, не являющегося массивом. Для массива он записывает
# в отдельных строках результат вызова to_s для каждого элемента массива.

# Чтобы проверить это, мы можем добавить собственный метод to_s в наш класс GoodCat, переопределив стандартный to_s,
# поставляемый с Ruby.

=begin
И да, это работает! Мы смогли изменить вывод, переопределив метод экземпляра to_s.

Существует еще один метод p, очень похожий на puts, только он не вызывает to_s для своего аргумента, 
а вызывает другой встроенный метод экземпляра Ruby, называемый inspect. Метод inspect очень полезен для
отладки, поэтому мы не хотим переопределять его.

Помимо автоматического вызова при использовании puts, еще одним важным свойством метода to_s является то,
 что он также автоматически вызывается при интерполяции строк.

Таким образом, метод to_s вызывается автоматически на объекте, когда мы используем его с помощью puts
или при использовании строковой интерполяции. На данный момент этот факт может показаться тривиальным,
но знание того, когда вызывается to_s, поможет нам понять, как читать и писать более качественный ОО-код.


=end

p tom # эквивалентно puts tom.inspect.

# Overriding #to_s остановился.
