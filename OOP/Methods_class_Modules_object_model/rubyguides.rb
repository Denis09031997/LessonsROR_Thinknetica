# Освоение регулярных выражений Ruby https://www.rubyguides.com/2015/06/ruby-regex/

=begin
Освоение регулярных выражений Ruby
автор Хесус Кастелло
Регулярные выражения Ruby (сокращенно ruby regex) помогают находить определенные шаблоны в строках с целью извлечения
данных для дальнейшей обработки.

Два распространенных случая использования регулярных выражений - проверка и синтаксический анализ.

Например:

Подумайте об адресе электронной почты. С помощью ruby regex вы можете определить, как выглядит правильный адрес
электронной почты. Другими словами, ваша программа сможет отличить действительный адрес электронной почты от 
недействительного.

Регулярные выражения Ruby задаются между двумя прямыми косыми чертами, что отличает их от синтаксиса других языков. 
Самые простые выражения соответствуют слову или даже одной букве.

Найдите слово 'like':

=end

# Find the word 'like'
puts "Do you like cats?" =~ /like/ # Возвращает индекс первого вхождения слова, если оно было найдено 
# (успешное совпадение), или nil в противном случае. Если нам не важен индекс, мы можем использовать метод String#include?

# Другой способ проверить, соответствует ли строка регексу, - использовать метод match:

if "Do you like cats?".match(/like/)
  puts "Match found!"
end

puts '-' * 120

# Вы узнаете, как создавать более сложные шаблоны, чтобы сопоставлять, захватывать и заменять такие вещи, как даты, 
# номера телефонов, электронные письма, URL-адреса и т. д.

# Классы персонажей

=begin
Класс символов позволяет определить диапазон или список символов для сопоставления. Например, [aeiou] 
соответствует любой гласной.

=end

def contains_vowel(str)
  str =~ /[aeiou]/
end

puts contains_vowel('Denis')
puts contains_vowel('Sponge')
puts contains_vowel('Bljbr')
# При этом не учитывается количество символов, но мы скоро узнаем, как это сделать.

=begin
Диапазоны
Мы можем использовать диапазоны, чтобы сопоставить несколько букв или цифр без необходимости вводить их все. 
Другими словами, диапазон [2-5] - это то же самое, что и [2345].

Некоторые полезные диапазоны:

[0-9] соответствует любому числу от 0 до 9
[a-z] соответствует любой букве от a до z (без заглавных букв)
[^a-z] отрицаемый диапазон
=end

puts 'Пример: Содержит ли эта строка какие-либо числа?'

def contains_number(str)
  str =~ /[0-9]/
end

puts contains_number('My name  is Denis.')
puts contains_number('My years 26.')
# Помните: возвращаемое значение при использовании `=~` - это либо индекс строки, либо `nil`.

puts '.' * 120
=begin
Существует удобный синтаксис для указания диапазонов символов:

\w эквивалентно [0-9a-zA-Z_]
\d - то же самое, что [0-9]
\s соответствует белому пространству (табуляции, обычному пробелу, новой строке).
Существует также их отрицательная форма:

\W все, что не входит в [0-9a-zA-Z_]
\D все, что не является числом
\S все, что не является пробелом
Символ точки . соответствует всему, кроме новых строк. Если вам нужно использовать литерал ., 
то его нужно экранировать.

Пример: Экранирование специальных символов

=end

puts 'Пример: Экранирование специальных символов:'

puts "5a5".match(/\d.\d/)

# В этом случае совпадает только литеральная точка:
puts "5a5".match(/\d\.\d/) # nil
puts "5.5".match(/\d\.\d/) # match

=begin
Модификаторы
До сих пор мы могли сопоставлять только один символ за раз. Для сопоставления нескольких символов мы можем 
использовать модификаторы шаблона.

MODIFIER	     DESCRIPTION
+	             1 или более
*	             0 или более
?	             0 или 1
{3,5}	         от 3 до 5

=end
puts '-' * 100

# Мы можем комбинировать все, что узнали до сих пор, для создания более сложных регулярных выражений.

# Похоже ли это на IP-адрес?

# Обратите внимание, что это также будет соответствовать некорректному IP-адресу
#, например 999.999.999.999, но в данном случае нам важен только формат.

def ip_address?(str)
  # Мы используем !! для преобразования возвращаемого значения в булеву величину
  !!(str =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)
end

puts ip_address?('192.168.1.1')
puts ip_address?('12.33.3')

=begin
Точное соответствие строк
Если вам нужно точное соответствие, вам понадобится другой тип модификатора. Давайте рассмотрим пример, 
чтобы вы могли понять, о чем я говорю:

=end

# Мы хотим найти, если эта строка состоит ровно из четырех букв.
# все равно совпадет, потому что в ней больше четырех, но это не то, что нам нужно.
puts "Regex are cool".match /\w{4}/

# Вместо этого мы будем использовать модификаторы 'beginning of line' и 'end of line'.
puts "Regex are cool".match /^\w{4}$/

# На этот раз он не совпадет. Это довольно надуманный пример, поскольку мы могли бы просто
# использовать .size для нахождения длины, но я думаю, что он доносит идею.

# Чтобы совпадать строго в начале строки, а не только в каждой строке (после \n), нужно использовать \A и \Z 
# вместо ^ и $.

puts '-' * 100

=begin
Группы захвата
С помощью групп захвата мы можем захватить часть совпадения и использовать ее в дальнейшем. Чтобы захватить совпадение,
мы заключаем часть, которую хотим захватить, в круглые скобки.

=end

Line = Struct.new(:time, :type, :msg)
LOG_FORMAT = /(\d{2}:\d{2}) (\w+) (.*)/

def parse_line(line)
  line.match(LOG_FORMAT) { |m| Line.new(*m.captures) }
end

parse_line("12:41 INFO User has logged in.")
# This produces objects like this:

=begin
В этом примере мы используем .match вместо =~.

Этот метод возвращает объект MatchData, если есть совпадение, и nil в противном случае. Класс MatchData имеет 
множество полезных методов, ознакомьтесь с документацией, чтобы узнать больше!

Если вам нужно просто булево значение (true / false), то вы можете использовать метод match?, который доступен 
начиная с Ruby 2.4. Он также быстрее, чем match, поскольку Ruby не нужно создавать объект MatchData.

Вы можете получить доступ к захваченным данным, используя метод .captures или рассматривая объект MatchData как массив, 
нулевой индекс будет содержать полное совпадение, а последующие индексы будут содержать совпадающие группы.

Комментирование кода:

**Как работает код: Пошаговая реализация и комментарии**

```ruby
# Создание структуры данных Line (строка), представляющей собой запись в журнале.
Line = Struct.new(:time, :type, :msg)

# Определение формата записи в журнале с использованием регулярного выражения.
# Регулярное выражение состоит из трех групп:
# 1. (\d{2}:\d{2}) - две цифры, двоеточие, еще две цифры (время)
# 2. (\w+) - одно или более словесных символов (тип)
# 3. (.*) - любой символ (ноль или более раз) (сообщение)
LOG_FORMAT = /(\d{2}:\d{2}) (\w+) (.*)/

# Определение функции parse_line для разбора строки на составляющие с использованием регулярного выражения.
def parse_line(line)
  # Вызов метода match для строки line с использованием регулярного выражения LOG_FORMAT.
  # Блок { |m| Line.new(*m.captures) } принимает объект MatchData m и создает новый объект Line
  # с использованием захваченных групп (captures) из регулярного выражения.
  line.match(LOG_FORMAT) { |m| Line.new(*m.captures) }
end

# Пример работы функции parse_line с передачей строки "12:41 INFO User has logged in."
parse_line("12:41 INFO User has logged in.")
```

**Комментарии:**

1. **Line = Struct.new(:time, :type, :msg):** Создание структуры данных `Line` с тремя полями: `time`, `type` и `msg`.

2. **LOG_FORMAT = /(\d{2}:\d{2}) (\w+) (.*)/:** Определение регулярного выражения `LOG_FORMAT`, которое определяет 
формат записи в журнале, состоящей из времени, типа и сообщения.

3. **def parse_line(line):** Определение функции `parse_line`, которая принимает строку и разбирает ее на составляющие 
с использованием регулярного выражения.

4. **line.match(LOG_FORMAT) { |m| Line.new(*m.captures) }:** Вызов метода `match` для строки `line` с использованием 
регулярного выражения `LOG_FORMAT`. Если совпадение найдено, блок принимает объект `MatchData` `m` и создает новый 
объект `Line` с использованием захваченных групп.

5. **Пример работы:**
   ```ruby
   parse_line("12:41 INFO User has logged in.")
   # Возвращает объект Line со значениями:
   # time: "12:41", type: "INFO", msg: "User has logged in."
   ```
=end

m = "John 31".match /\w+ (\d+)/

puts m[1]
# 31

puts parse_line("12:41 INFO User has logged in.")

puts '-' * 120

=begin
Вы также можете иметь группы без захвата. Они позволят вам группировать выражения вместе без ущерба для 
производительности. Вы также можете найти именованные группы полезными для облегчения чтения сложных выражений.

SYNTAX	                DESCRIPTION
(?:...)	                Non-capturing group
(?<foo>...)	            Named group
=end

puts 'Пример. Название группы:'
m = "David 30".match /(?<name>\w+) (?<age>\d+)/
puts m[:age]
puts m[:name]


=begin
Разбор кода выше:

Давайте пошагово разберем, как работает этот код:

```ruby
# Создаем строку
m = "David 30".match /(?<name>\w+) (?<age>\d+)/
```

1. Создаем строку `"David 30"`.
2. Используем метод `match` для сопоставления строки с регулярным выражением `/(?<name>\w+) (?<age>\d+)/`.

Теперь разберем регулярное выражение:

- `(?<name>\w+)`: Эта часть регулярного выражения создает именованную группу с именем `name`, которая 
соответствует одному или более буквенно-цифровым символам (слово).
- `(?<age>\d+)`: Эта часть создает именованную группу `age`, которая соответствует одной или более цифровой 
цифре (возраст).

Теперь посмотрим, как `match` обрабатывает результат:

```ruby
# Выводим результаты сопоставления
puts "Имя: #{m[:name]}, Возраст: #{m[:age]}"
```

- `m[:name]` и `m[:age]` позволяют получить значения, соответствующие именованным группам в регулярном выражении.

Таким образом, код создает объект `MatchData`, содержащий результаты сопоставления для данной строки и 
регулярного выражения. В данном случае, `m` будет содержать именованные группы `name` и `age`, представляющие имя 
и возраст из строки "David 30".
=end

# Именованная группа возвращает объект MatchData, к которому вы можете обратиться для чтения результатов.

puts '-' * 120
puts 'Смотреть вперед и назад.'
puts '-' * 120

=begin
Смотреть вперед и смотреть назад
Это более продвинутая техника, которая может быть доступна не во всех реализациях regex. Движок регулярных 
выражений Ruby умеет это делать, так что давайте посмотрим, как этим воспользоваться.

Заглянуть вперед позволяет нам посмотреть, есть ли определенное совпадение до или после.

NAME	            DESCRIPTION
(?=pat)	          Positive lookahead
(?<=pat)	        Positive lookbehind
(?!pat)	          Negative lookahead
(?<!pat)	        Negative lookbehind
=end

# Например: есть ли число, которому предшествует хотя бы одна буква?

def number_after_word?(str)
  !!(str =~ /(?<=\w) (\d+)/)
end

puts number_after_word?("Grade 99")

puts '.' * 120
puts 'Класс Regex в Ruby'
puts '.' * 120

=begin
Регулярные выражения Ruby - это экземпляры класса Regexp. В большинстве случаев вы не будете использовать этот 
класс напрямую, но знать его полезно 🙂 .

Один из возможных вариантов использования - создание регекса из строки:

regexp = Regexp.new("a")

Другой способ создания regexp:

regexp = %r{\w+}

=end

puts /a/.class
# Regexp
regexp = Regexp.new("a")
regexp2 = %r{\w+}

puts "Regexp = #{regexp}, regexp2 = #{regexp2}"

# Параметры Regex
# Вы можете задать некоторые параметры регулярного выражения, чтобы заставить его вести себя по-другому.

=begin
OPTIONS	                DESCRIPTION
   i	                   ruby regex нечувствительный к регистру
   m	                   Точка совпадает с новой строкой
   x	                   игнорировать пробельные символы
=end

# Чтобы использовать эти опции, добавьте букву в конец регекса, после закрывающего /.

puts 'Пример:'

puts "abc".match?(/[A-Z]/i)

=begin
Данный код проверяет, содержит ли строка "abc" хотя бы одну букву (символ), которая является заглавной или строчной. 
Регулярное выражение `/[A-Z]/i` означает любую букву от A до Z (в верхнем регистре) или от a до z (в нижнем регистре), 
и флаг `i` делает матч регистронезависимым.

Таким образом, если строка "abc" содержит хотя бы одну букву (любого регистра), то выражение `match?` вернет `true`. 
В данном случае, так как строка "abc" содержит буквы "a", "b" и "c", которые все являются строчными, то выражение 
вернет `true`.
=end

=begin
Форматирование длинных регулярных выражений
Сложные регулярные выражения Ruby может быть довольно трудно читать, поэтому будет полезно разбить их на 
несколько строк. Это можно сделать с помощью модификатора 'x'. Этот формат также позволяет использовать 
комментарии внутри регулярного выражения.

=end

puts '------------------- ФОРМАТИРОВАНИЕ ДЛИННЫХ РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ ----------------'

LOG_FORMAT = %r{
  (\d{2}:\d{2}) # Time
  \s(\w+)       # Event type
  \s(.*)        # Message
}x

=begin
Разбор кода:

Этот код определяет регулярное выражение (Regexp) под названием `LOG_FORMAT`. Давайте пошагово разберем его структуру 
и функциональность:

1. `%r{}` - Это специальный синтаксис для создания регулярного выражения в Ruby. Здесь `{}` используется вместо 
обычных косых черт `/.../`, что делает выражение более удобным для включения в код с многострочным форматированием 
(`x` в конце также помогает в этом).

2. `(\d{2}:\d{2})` - Группа, которая соответствует времени в формате "чч:мм". `\d` обозначает цифровой символ, 
а `{2}` указывает на то, что предыдущий элемент должен повторяться дважды.

3. `\s` - Соответствует любому пробельному символу (пробелу, табуляции и т. д.).

4. `(\w+)` - Группа, которая соответствует одному или более буквенно-цифровым символам (включая подчеркивание). 
Это соответствует типу события.

5. `\s` - Еще один пробельный символ.

6. `(.*)` - Группа, которая соответствует нулю или более любым символам (кроме новой строки). Это соответствует 
сообщению.

Таким образом, данное регулярное выражение предполагает, что строки в формате лога имеют следующую структуру: 
"чч:мм ТИП_СОБЫТИЯ СООБЩЕНИЕ", где "чч:мм" - это время, "ТИП_СОБЫТИЯ" - тип события, а "СООБЩЕНИЕ" - текстовое 
описание события.
=end

puts 'Пример использования:'

log_line = "12:34 INFO Something happened"
match_data = log_line.match(LOG_FORMAT)

if match_data
  time = match_data[1] # Время
  event_type = match_data[2] # Тип события
  message = match_data[3] # Сообщение

  puts "Time: #{time}"
  puts "Event Type: #{event_type}"
  puts "Message: #{message}"
else
  puts "Log line does not match the expected format."
end

puts '______________________________________________________________________'

=begin
Ruby regex: Собираем все вместе
Регулярные выражения можно использовать во многих методах Ruby.

.split
.scan
.gsub
and many more…

=end

puts 'Пример: Сопоставление всех слов из строки с помощью функции .scan'

p "this is some string".scan(/\w+/)

puts 'Пример: Извлечение всех чисел из строки'
p "The year was 1492.".scan(/\d+/)

puts 'Пример: Выделите все слова в строке заглавными буквами'
str = "lord of the rings"

puts str.gsub(/\w+/) { |w| w.capitalize }

puts 'Пример: Проверка адреса электронной почты'
email = "test@example.com"

puts !!email.match(/\A[\w.+-]+@\w+\.\w+\z/)

# Разбор кода проверки эл.почты

=begin
Этот код использует регулярное выражение для проверки строки `email` на соответствие стандартному формату 
электронной почты. Давайте разберем его пошагово:

1. `email.match(...)`: Этот метод проверяет, соответствует ли строка `email` заданному регулярному выражению.

2. `\A`: Это якорь начала строки. Гарантирует, что соответствие должно начинаться с начала строки.

3. `[\w.+-]+`: Это символьный класс, который соответствует одному или более символам, являющимся буквами, 
цифрами, точкой, плюсом или минусом.

4. `@`: Обязательный символ "@" в адресе электронной почты.

5. `\w+`: Снова один или более символов, являющихся буквами или цифрами. Это соответствует домену перед точкой 
в адресе электронной почты.

6. `\.`: Обязательная точка между именем домена и доменным уровнем.

7. `\w+`: Снова один или более символов, являющихся буквами или цифрами. Это соответствует доменному уровню 
после точки в адресе электронной почты.

8. `\z`: Это якорь конца строки. Гарантирует, что соответствие должно заканчиваться в конце строки.

Таким образом, выражение `\A[\w.+-]+@\w+\.\w+\z` описывает стандартный формат адреса электронной почты, 
и `!!` преобразует результат сопоставления в булево значение. Если строка `email` соответствует формату, 
результат будет `true`, в противном случае - `false`.

В последнем примере используется !! для преобразования результата в булево значение (true / false). 
В качестве альтернативы вы можете использовать метод match? в Ruby 2.4+, который уже делает это за вас, 
а также работает быстрее.


=end
