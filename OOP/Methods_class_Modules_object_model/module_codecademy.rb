=begin
Что такое модуль?
Модуль можно представить себе как набор инструментов, содержащий набор методов и констант. Существует множество
инструментов Ruby, которые вы можете захотеть использовать, но их постоянное использование загромождает интерпретатор.
По этой причине мы храним их в модулях, и только тогда, когда нам нужны константы и методы, находящиеся в модуле, мы
открываем этот набор инструментов!

Можно считать, что модули очень похожи на классы, только модули не могут создавать экземпляры и не могут иметь
подклассов. Они просто используются для хранения вещей!

Синтаксис модулей
Вы можете использовать уже существующие модули, но также можете создавать свои собственные.
Модули создаются очень просто! Достаточно использовать ключевое слово module, например, так:

module ModuleName
  # Bits 'n pieces
end

Имена модулей, как и имена классов, записываются в заглавных буквах (CapitalizedCamelCase), а не в строчных 
(lowercase_with_underscores).

Включать переменные в модули не имеет смысла, поскольку переменные (по определению) изменяются (или меняются). 
Константы же должны всегда оставаться неизменными, поэтому включение полезных констант в модули - отличная идея.

Ruby не заставляет вас сохранять одно и то же значение константы после ее инициализации, но предупредит вас, 
если вы попытаетесь его изменить. Константы Ruby записываются в ALL_CAPS и разделяются символами подчеркивания, 
если в них больше одного слова.

Примером константы Ruby является PI, которая находится в модуле Math и приблизительно равна 3.141592653589793. 
В предыдущем упражнении мы создали свою собственную константу PI, но не волнуйтесь: поскольку они находятся в 
разных модулях, Ruby знает, что их нужно хранить отдельно.

Одно из основных назначений модулей - разделение методов и констант по именованным пространствам. 
Это называется (достаточно удобно) namespacing, и именно благодаря этому Ruby не путает Math::PI и Circle::PI.

Видите двойное двоеточие, которое мы только что использовали? Это оператор разрешения области видимости, 
то есть он указывает Ruby, где искать тот или иной фрагмент кода. Если мы говорим Math::PI, то Ruby знает, 
что нужно искать внутри модуля Math, чтобы получить этот PI, а не какой-либо другой PI 
(например, тот, который мы создали в Circle).

Давайте немного попрактикуемся с существующим модулем Ruby: Math.

Некоторые модули, например Math, уже присутствуют в интерпретаторе. 
Однако другие необходимо явно привнести в интерпретатор, что можно сделать с помощью require. 
Для этого достаточно набрать - require 'module'




=end

# пример модуля

module Circle

  PI = 3.141592653589793

  def Circle.area(radius)
    PI * radius**2
  end

  def Circle.circumference(radius)
    2 * PI * radius
  end
end

puts Math::PI

# Создадим свой собственный модуль

module MyLibrary
  FAVE_BOOK = 'Думай и богатей'
end

require 'Date'
puts Date.today

=begin
Чувство включенности
Однако мы можем не только требовать модуль, но и включить его!

Любой класс, включающий определенный модуль, может использовать методы этого модуля!

Приятным следствием этого является то, что больше не нужно добавлять к константам и методам имя модуля. 
Поскольку все уже подтянуто, можно просто писать PI вместо Math::PI. (см.   include Math)

=end

class Angle
  
  include Math

  attr_accessor :radians
  
  def initialize(radians)
    @radians = radians
  end
  
  def cosine
    cos(@radians)
  end
end

# мы смешали поведение класса и модуля!

# Когда модуль используется для добавления дополнительного поведения и информации в класс, он называется миксином. 
# Миксины позволяют нам изменять класс без необходимости переписывать код!

acute = Angle.new(1)
p acute.cosine

=begin
миксины могут дать нам возможность имитировать наследование более чем от одного класса: смешивая черты из различных
модулей по мере необходимости, мы можем добавить в наши классы любую комбинацию поведения, которая нам нравится!
=end

module MartialArts
  def swordsman
    puts 'I\'m a swordsman.'
  end
end

class Ninja
  include MartialArts
  def initialize(clan)
    @clan = clan
  end
end

class Samurai
  include MartialArts

  def initialize(shogun)
    @shogun = shogun
  end
end

=begin
Расширение знаний
Если ключевое слово include подмешивает методы модуля на уровне экземпляров (позволяя экземплярам конкретного класса
использовать эти методы), то ключевое слово extend подмешивает методы модуля на уровне класса. Это означает, 
что сам класс может использовать методы, а не его экземпляры.

=end

module ThePresent
  def now
    puts "It's #{Time.new.hour > 12 ? Time.new.hour - 12 : Time.new.hour}:#{Time.new.min} #{Time.new.hour > 12 ? 'PM' : 'AM'} (GMT)."
  end
end

class TheHereAnd
  extend ThePresent
end

TheHereAnd.now

puts '-' * 120

# Попрактикуемся с публичными методами

class Application
  attr_accessor :status
  def initialize; end
  # Add your method here!
  public

  def print_status
    puts "All systems go!"
  end

  private

  def password
    return 12345
  end
end

puts 'теперь модули:'

module Languages
  FAVE = 'Ruby!'
end

class Master
  include Languages
  def initialize; end
  def victory
    puts FAVE
  end
end

total = Master.new
total.victory