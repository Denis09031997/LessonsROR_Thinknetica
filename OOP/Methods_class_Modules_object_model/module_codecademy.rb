=begin
Что такое модуль?
Модуль можно представить себе как набор инструментов, содержащий набор методов и констант. Существует множество
инструментов Ruby, которые вы можете захотеть использовать, но их постоянное использование загромождает интерпретатор.
По этой причине мы храним их в модулях, и только тогда, когда нам нужны константы и методы, находящиеся в модуле, мы
открываем этот набор инструментов!

Можно считать, что модули очень похожи на классы, только модули не могут создавать экземпляры и не могут иметь
подклассов. Они просто используются для хранения вещей!

Синтаксис модулей
Вы можете использовать уже существующие модули, но также можете создавать свои собственные.
Модули создаются очень просто! Достаточно использовать ключевое слово module, например, так:

module ModuleName
  # Bits 'n pieces
end

Имена модулей, как и имена классов, записываются в заглавных буквах (CapitalizedCamelCase), а не в строчных 
(lowercase_with_underscores).

Включать переменные в модули не имеет смысла, поскольку переменные (по определению) изменяются (или меняются). 
Константы же должны всегда оставаться неизменными, поэтому включение полезных констант в модули - отличная идея.

Ruby не заставляет вас сохранять одно и то же значение константы после ее инициализации, но предупредит вас, 
если вы попытаетесь его изменить. Константы Ruby записываются в ALL_CAPS и разделяются символами подчеркивания, 
если в них больше одного слова.

Примером константы Ruby является PI, которая находится в модуле Math и приблизительно равна 3.141592653589793. 
В предыдущем упражнении мы создали свою собственную константу PI, но не волнуйтесь: поскольку они находятся в 
разных модулях, Ruby знает, что их нужно хранить отдельно.

Одно из основных назначений модулей - разделение методов и констант по именованным пространствам. 
Это называется (достаточно удобно) namespacing, и именно благодаря этому Ruby не путает Math::PI и Circle::PI.

Видите двойное двоеточие, которое мы только что использовали? Это оператор разрешения области видимости, 
то есть он указывает Ruby, где искать тот или иной фрагмент кода. Если мы говорим Math::PI, то Ruby знает, 
что нужно искать внутри модуля Math, чтобы получить этот PI, а не какой-либо другой PI 
(например, тот, который мы создали в Circle).

Давайте немного попрактикуемся с существующим модулем Ruby: Math.

Некоторые модули, например Math, уже присутствуют в интерпретаторе. 
Однако другие необходимо явно привнести в интерпретатор, что можно сделать с помощью require. 
Для этого достаточно набрать - require 'module'




=end

# пример модуля

module Circle

  PI = 3.141592653589793

  def Circle.area(radius)
    PI * radius**2
  end

  def Circle.circumference(radius)
    2 * PI * radius
  end
end

puts Math::PI

# Создадим свой собственный модуль

module MyLibrary
  FAVE_BOOK = 'Думай и богатей'
end

require 'Date'
puts Date.today

=begin
Чувство включенности
Однако мы можем не только требовать модуль, но и включить его!

Любой класс, включающий определенный модуль, может использовать методы этого модуля!

Приятным следствием этого является то, что больше не нужно добавлять к константам и методам имя модуля. 
Поскольку все уже подтянуто, можно просто писать PI вместо Math::PI. (см.   include Math)

=end

class Angle
  
  include Math

  attr_accessor :radians
  
  def initialize(radians)
    @radians = radians
  end
  
  def cosine
    cos(@radians)
  end
end

# мы смешали поведение класса и модуля!

# Когда модуль используется для добавления дополнительного поведения и информации в класс, он называется миксином. 
# Миксины позволяют нам изменять класс без необходимости переписывать код!

acute = Angle.new(1)
p acute.cosine

=begin
миксины могут дать нам возможность имитировать наследование более чем от одного класса: смешивая черты из различных
модулей по мере необходимости, мы можем добавить в наши классы любую комбинацию поведения, которая нам нравится!
=end

module MartialArts
  def swordsman
    puts 'I\'m a swordsman.'
  end
end

class Ninja
  include MartialArts
  def initialize(clan)
    @clan = clan
  end
end

class Samurai
  include MartialArts

  def initialize(shogun)
    @shogun = shogun
  end
end