# https://www.honeybadger.io/blog/a-beginner-s-guide-to-exceptions-in-ruby/
# Руководство для начинающих по исключениям в Ruby

=begin
Что такое исключение?
Исключения - это способ Ruby справиться с неожиданными событиями.

Если вы когда-нибудь делали опечатку в своем коде, что приводило к аварийному завершению программы с сообщением типа
SyntaxError или NoMethodError, то вы видели исключения в действии.

Когда вы вызываете исключение в Ruby, мир останавливается, и ваша программа начинает завершать работу
Если ничто не остановит процесс, ваша программа в конце концов завершится с сообщением об ошибке.

Вот пример. В приведенном ниже коде мы пытаемся разделить на ноль. Это невозможно, поэтому Ruby вызывает
исключение ZeroDivisionError. Программа завершается и выводит сообщение об ошибке.

1 / 0
Program crashes and outputs: "ZeroDivisionError: divided by 0"

Сбойные программы обычно злят наших пользователей. Поэтому мы обычно хотим остановить этот процесс выключения и 
разумно отреагировать на ошибку.

Это называется "спасением", "обработкой" или "поимкой" исключения. Все они означают одно и то же. Вот как это делается 
в Ruby:


=end

begin
  # Any exceptions in here... 
  1/0
rescue
  # ...will cause this code to run
  puts "Got an exception, but I'm responding intelligently!"
end

=begin
Исключение все еще происходит, но оно не приводит к аварийному завершению программы, потому что она была "спасена".
Вместо выхода Ruby выполняет код в спасательном блоке, который выводит сообщение.

Это хорошо, но у этого есть одно большое ограничение. Оно сообщает нам "что-то пошло не так", не давая понять,
что именно.

Вся информация о том, что именно пошло не так, будет содержаться в объекте исключения.

=end

=begin
Объекты исключений
Объекты исключений - это обычные объекты Ruby. Они хранят все данные о том, что произошло с исключением, 
которое вы только что спасли.

Чтобы получить объект исключения, вы будете использовать немного другой синтаксис спасения.

# Исправляет все ошибки и помещает объект исключения в `e`.
rescue => e

# Восстанавливает только ZeroDivisionError и помещает объект исключения в `e`.
rescue ZeroDivisionError => e

Во втором примере ZeroDivisionError - это класс объекта в e. Все "типы" исключений, о которых мы говорили, на 
самом деле просто имена классов.

Объекты исключений также содержат полезные отладочные данные. Давайте посмотрим на объект исключения для 
нашего ZeroDivisionError.

=end
puts '.' * 120
begin
  # Any exceptions in here... 
  1/0
rescue ZeroDivisionError => e
  puts "Exception Class: #{ e.class.name }"
  puts "Exception Message: #{ e.message }"
  puts "Exception Backtrace: #{ e.backtrace }"
end

puts '-' * 120

# Как и большинство исключений Ruby, оно содержит сообщение и трассировку, а также имя класса.

=begin
Выращивание собственных исключений
До сих пор мы говорили только о спасении исключений. Вы также можете создавать собственные исключения. 
Этот процесс называется "поднятием". Для этого нужно вызвать метод raise.

Когда вы поднимаете собственные исключения, вы можете выбрать, какой тип исключения использовать. 
Вы также можете задать сообщение об ошибке.
=end

begin
  # вызывает ошибку ArgumentError с сообщением "Вы что-то напутали!".
  raise ArgumentError.new("You messed up!")
rescue ArgumentError => e
  puts e.message
end

=begin
Как видите, мы создаем новый объект ошибки (ArgumentError) с пользовательским сообщением ("You messed up!")
и передаем его в метод raise.

В Ruby метод raise может быть вызван несколькими способами:

1 - raise RuntimeError.new("You messed up!")

2 - raise RuntimeError, "You messed up!"

3 - raise "You messed up!"

=end

puts '-' * 100

=begin
Создание пользовательских исключений
Встроенные в Ruby исключения - это здорово, но они не покрывают все возможные случаи использования.

Что если вы создаете пользовательскую систему и хотите вызывать исключение, когда пользователь пытается
получить доступ к запрещенной части сайта? Ни одно из стандартных исключений Ruby не подходит, поэтому лучше всего 
создать новый тип исключения.

Чтобы создать пользовательское исключение, просто создайте новый класс, который наследуется от StandardError.

=end

# Это обычный класс Ruby. Это значит, что вы можете добавлять в него методы и данные, как в любой другой класс.
# Давайте добавим атрибут под названием "action":



class PermissionDeniedError < StandardError

  attr_reader :action

  def initialize(message, action)
    # Вызовите конструктор родителя, чтобы установить сообщение
    super(message)
    # Сохраните действие в переменной экземпляра
    @action = action
  end
end


# Затем, когда пользователь попытается удалить то, на что у него нет
# не имеет разрешения на удаление, вы можете сделать что-то вроде этого:
raise PermissionDeniedError.new("Permission Denied", :delete)

# Иерархия классов
# Мы только что создали пользовательское исключение, подклассифицировав StandardError, который сам является подклассом 
# Exception.

# На самом деле, если вы посмотрите на иерархию классов любого исключения в Ruby, то обнаружите, 
# что в конечном итоге она ведет к Exception. Сейчас я вам это докажу. Вот большинство встроенных исключений Ruby, 
# представленных в иерархическом порядке:

=begin
Exception
 NoMemoryError
 ScriptError
   LoadError
   NotImplementedError
   SyntaxError
 SignalException
   Interrupt
 StandardError
   ArgumentError
   IOError
     EOFError
   IndexError
   LocalJumpError
   NameError
     NoMethodError
   RangeError
     FloatDomainError
   RegexpError
   RuntimeError
   SecurityError
   SystemCallError
   SystemStackError
   ThreadError
   TypeError
   ZeroDivisionError
 SystemExit
=end

# Исправление ошибок конкретного класса также исправляет ошибки его дочерних классов.

#  КОНСПЕКТ:

=begin
**Исключения в Ruby: Конспект**

**1. Введение в исключения:**
   - **Исключения (Exceptions)** в Ruby представляют собой специальные объекты, сигнализирующие о возникновении 
   ошибки во время выполнения программы.
   - Обработка исключений позволяет программе корректно реагировать на ошибки и избегать аварийного завершения.

**2. Основные типы исключений в Ruby:**
   - **StandardError:** Базовый класс для большинства встроенных исключений.
   - **RuntimeError:** Подкласс StandardError, используется для ошибок времени выполнения.

**3. Создание исключений:**
   - Исключения в Ruby могут быть как встроенными (стандартными), так и пользовательскими.
   - **Встроенные исключения:** Ruby предоставляет множество встроенных исключений, таких как `ArgumentError`, 
   `ZeroDivisionError`, `TypeError` и т.д.
   - **Пользовательские исключения:** Определение новых классов исключений путем наследования от `StandardError` 
   или его подклассов.

   ```ruby
   class CustomError < StandardError
     # ...
   end
   ```

**4. Блоки `begin`, `rescue`, `ensure` и `else`:**
   - **`begin`:** Метка начала блока, в котором может возникнуть исключение.
   - **`rescue`:** Блок для обработки исключений.
   - **`ensure`:** Блок, который выполняется всегда, независимо от того, произошло исключение или нет.
   - **`else`:** Блок, который выполняется, если исключение не возникло.

   ```ruby
   begin
     # код, в котором может произойти ошибка
   rescue SomeError => e
     # обработка исключения
   else
     # код, выполняемый, если исключение не возникло
   ensure
     # код, выполняемый всегда
   end
   ```

**5. Использование исключений в ООП:**
   - В ООП исключения могут быть использованы для обработки ошибок в методах классов.
   - Создание пользовательских исключений с добавлением дополнительной информации о возникшей ошибке.

   ```ruby
   class Car
     def start_engine
       # некоторый код
       raise EngineStartError.new("Error starting engine")
     rescue EngineStartError => e
       puts "Engine start failed: #{e.message}"
     end
   end

   class EngineStartError < StandardError
     # дополнительные свойства или методы
   end
   ```

**Примеры:**
   
   ```ruby
   # Пример 1: Встроенные исключения
   begin
     result = 10 / 0
   rescue ZeroDivisionError => e
     puts "Error: #{e.message}"
   end

   # Пример 2: Пользовательское исключение
   class CustomError < StandardError
     # дополнительные свойства или методы
   end

   begin
     raise CustomError.new("Custom error occurred")
   rescue CustomError => e
     puts "Custom Error: #{e.message}"
   end

   # Пример 3: Использование исключений в ООП
   class TemperatureError < StandardError
     # дополнительные свойства или методы
   end

   class Thermostat
     def set_temperature(value)
       raise TemperatureError.new("Invalid temperature") if value < -50 || value > 50
       puts "Temperature set to #{value} degrees Celsius."
     rescue TemperatureError => e
       puts "Temperature setting failed: #{e.message}"
     end
   end

   thermostat = Thermostat.new
   thermostat.set_temperature(75)
   thermostat.set_temperature(-60)
   ```

**Вывод:**
Исключения в Ruby предоставляют элегантный механизм обработки ошибок, обеспечивая безопасность и 
управляемость выполнения программы при возникновении проблем. Пользовательские исключения позволяют разработчикам
создавать более информативные и адаптированные к конкретным ситуациям ошибки.
=end