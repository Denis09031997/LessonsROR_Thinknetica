# Модули и миксины: www.codecademy.com
=begin
По этой причине Ruby позволяет явно сделать одни методы публичными, а другие - приватными. Публичные методы
обеспечивают интерфейс с остальной частью программы; они говорят: "Эй! Спросите меня, если вам нужно узнать что-то
о моем классе или его экземплярах".

Частные методы, с другой стороны, предназначены для того, чтобы ваши классы могли спокойно заниматься своими делами.
Они не хотят, чтобы кто-то спрашивал их о чем-то, поэтому они делают себя недоступными!

=end

class Person

  def initialize(name, age)
    @name = name
    @age = age
  end

  public    # Этот метод может быть вызван извне класса.

  def about_me
    puts "I'm #{@name} and I'm #{@age} years old!"
  end

  private   # Этот метод не может!

  def bank_account_number
    @account_number = 12345
    puts "My bank account number is #{@account_number}."
  end
end

eric = Person.new("Eric", 26)
eric.about_me
# eric.bank_account_number

# Мы создали публичный метод about_me и приватный метод bank_account_number
# Попытаемся вызвать метод bank_account_number извне класса - получим ошибку

=begin
Приватные методы являются именно такими: они приватны для объекта, в котором они определены. Это означает, что
эти методы можно вызывать только из другого кода внутри объекта. Другой способ сказать это - метод не может быть
вызван с явным приемником. Вы все время использовали приемники - это объекты, на которых вызываются методы!
Всякий раз, когда вы вызываете object.method, объект является приемником метода.

Методы, объявленные как private в Ruby, становятся недоступными извне объекта, включающего этот метод.
Это предоставляет механизм инкапсуляции, который ограничивает доступ к определенным частям функциональности класса.

Суть и применение private:
Инкапсуляция: Одним из принципов объектно-ориентированного программирования (ООП) является инкапсуляция,
которая заключается в объединении данных (переменных) и методов, работающих с этими данными, в одну единицу (класс)
и скрытии деталей реализации от внешнего мира.

Скрытие служебных методов: Методы, объявленные как private, предназначены для использования внутри класса и не
предназначены для прямого вызова извне. Это позволяет скрыть служебные методы, которые не должны быть доступными
для внешних клиентов класса.

Чтобы получить доступ к частной информации, мы должны создать публичные методы, которые знают, как ее получить. 
Это отделяет частную реализацию от публичного интерфейса

attr_reader, attr_writer
В уроке по классам мы видели, что для доступа к атрибутам в Ruby необходимы методы. Например, 
если мы хотим получить доступ к переменной экземпляра @name, мы должны были написать что-то вроде:

def name
  @name
end

Больше нет! Мы можем использовать attr_reader для доступа к переменной и attr_writer для ее изменения.
Если мы напишем:

class Person
  attr_reader :name
  attr_writer :name
  def initialize(name)
    @name = name
  end
end

Ruby делает нечто подобное для нас автоматически:

def name
  @name
end

def name=(value)
  @name = value
end

Мы просто передаем переменные экземпляра (в виде символов) в attr_reader или attr_writer.

(Это имя= может показаться смешным, но в имени метода разрешается ставить знак =. Это просто соглашение Ruby, 
говорящее: "Эй, этот метод устанавливает значение!").

attr_accessor
Если мы хотим и читать, и записывать определенную переменную, есть еще более короткий путь, чем 
использование attr_reader и attr_writer. С помощью attr_accessor можно одним махом сделать переменную 
доступной для чтения и записи.


=end



# Начнем создавать класс:

class Dog

  def initialize(name, breed)
    @name = name
    @breed = breed
  end

  public

  def bark
    puts 'Woof!'
  end

  private

  def id
    @id_number = 12345
  end
end

