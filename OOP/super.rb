=begin
super в Ruby используется в контексте наследования и позволяет вызывать методы из родительского класса в подклассе.
Это особенно полезно, когда подкласс переопределяет метод родительского класса, но все еще хочет использовать
функциональность родительского метода.

Давайте рассмотрим примеры с пошаговыми комментариями:

Пример 1: Простое наследование и использование super

=end

class Animal
  def sound
    puts "Some generic sound"
  end
end

class Cat < Animal
  def sound
    puts "Meow!"
    super # Вызываем метод sound родительского класса
  end
end

cat = Cat.new
cat.sound

=begin

class Animal...: Создается класс Animal, который имеет метод sound.

class Cat < Animal...: Создается подкласс Cat, который наследует функциональность от Animal.

def sound...: В подклассе Cat переопределяется метод sound. При этом сначала выводится "Meow", а затем вызывается super.

super: Это вызов метода sound из родительского класса Animal. В данном случае, он выведет "Some generic sound".

=end

# Еще пример:

class Person
  def initialize(name)
    @name = name
  end
end

class Student < Person
  def initialize(name, grade)
    super(name) # Вызываем конструктор родительского класса
    @grade = grade
  end
end

student1 = Person.new('Denis')
puts student1.inspect
student2 = Student.new('Sveta', '5+')
puts student2.inspect

=begin
class Person...: Создается класс Person с конструктором, принимающим аргумент name.

class Student < Person...: Создается подкласс Student, который наследует функциональность от Person.

def initialize...: В подклассе Student переопределяется конструктор initialize. При этом сначала вызывается super(name),
что передает аргумент name конструктору родительского класса Person.

@grade = grade: В подклассе Student добавляется атрибут @grade.

Создается объект Student с именем "John" и оценкой "A".

puts student.inspect: Выводится информация о созданном объекте student.

=end

puts '______________________________________________________________________'

# Ещё немного о переменных  @ и @@

=begin
Переменные с символом @ и @@ в Ruby представляют разные типы переменных, а именно инстанс-переменные и классовые переменные.

Инстанс-переменные (@):

Инстанс-переменные принадлежат конкретному объекту и хранят информацию о его состоянии.
Они видны только в пределах этого объекта.
Каждый объект имеет свою собственную копию инстанс-переменной.
=end

class ClassName1
  def initialize(name)
    @name = name # @name - инстанс-переменная
  end

  def say_name
    puts "My name is #{@name}"
  end
end

my_name = ClassName1.new('Denis')
my_name.say_name

=begin
Классовые переменные (@@):

Классовые переменные принадлежат всему классу и видны в пределах всех объектов этого класса и его подклассов.
Они используются для хранения информации, которая должна быть общей для всех объектов класса.
Классовая переменная имеет одно значение для всех объектов этого класса.
=end

class ClassName2
  @@count = 0 # @@count - классовая переменная

  def initialize(name)
    @name = name
    @@count += 1
  end

  def self.total_count # Метод класса для доступа к классовой переменной
    @@count
  end
end

x1 = ClassName2.new('John')
x2 = ClassName2.new('Jessica')
puts ClassName2.total_count # Вывод: 2 (поскольку создано два объекта класса Person)

=begin
Итак, основные различия:

Инстанс-переменные принадлежат объекту и хранят его состояние.
Классовые переменные принадлежат классу и используются для общей информации между всеми объектами этого класса и его подклассами.
Важно помнить, что использование классовых переменных может привести к проблемам с многопоточностью, так как они разделяются между всеми потоками выполнения.
=end