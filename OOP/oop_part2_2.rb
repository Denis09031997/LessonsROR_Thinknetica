# ПРОДОЛЖЕНИЕ OOP_PART2

=begin

чтобы понять, как объекты разных классов взаимодействуют друг с другом в ООП парадигме, сделаем для начала две вещи:

первое:
давайте добавим класс Driver
и пусть задание (ТЗ) для него звучит следующим образом

класс Водитель:

“Имеет имя, которое указывается при создании”
“Может возвращать имя”
второе:
изменим ТЗ для класса Car, чтобы оно теперь выглядело как описано ниже

класс Автомобиль:

“Имеет номер, который указывается при создании”
“Может возвращать номер”
“Имеет цвет, при создании цвет устанавливается в значение ‘white’”
“Может возвращать цвет, может менять цвет”
“Может выводить в консоли ‘beep beep’”
“Знает допущенных к управлению водителей”
“Может добавлять водителей в список водителей”
“Может возвращать список водителей”
“Может выводить список имен водителей”

=end

# начнем мы с изменения уже существующего класса MyCar. что изменилось в ТЗ?

=begin

начнем мы с изменения уже существующего класса Car
что изменилось в ТЗ?

“Может возвращать номер” означает, что нужно добавить метод, который возвращает значение инстанс-переменной, т.е. 
геттер
это легко реализуемо добавлением в класс одной строчки:

attr_reader :number
“Знает допущенных к управлению водителей” vs. “Знает имена, допущенных к управлению водителей”…
что означает это почти незаметное изменение в ТЗ?
оно означает, что теперь мы должны хранить в инстанс-переменной объекта car* не строки, а что-то другое… и это “другое” - 
это объект класса Driver
другими словами: объект класса Car должен хранить в своей переменной объекты класса Driver
эта модификация не требует больших изменений, разве что переименования переменной drivers_names в drivers (для простоты 
чтения и понимания кода):

вместо

attr_reader :drivers_names
теперь стоит написать

attr_reader :drivers
и аналогичным образом поменять имя переменной в initialize: c @drivers_names, на @drivers
поменяв имя ридера мы также выполнили пункт “Может возвращать список водителей”

“Может добавлять водителей в список водителей” vs. “Может добавлять имена водителей в список имен водителей”
здесь изменения следуют той же логике, что и в предыдущем пункте - мы просто правим метод так, чтобы речь уже шла не об 
операциях со строкой, а об операциях с объектом класса Driver
вместо

def add_driver(name)
  @drivers_names << name
end

напишем

def add_driver(driver)
  @drivers << driver
end


Следуя той же логике меняем метод show_drivers, теперь он будет выглядеть так:

def show_drivers
  @drivers.each { |driver| puts driver.name }
end
здесь стоит обратить внимание на следующий момент, который нередко бывает не совсем ясен студентам
если раньше мы перебирали элементы массива, являвшиеся строками и выводили их по очереди, то в новом методе мы перебираем элементы, каждый из которых - объект класса Driver
этих объектов не существует в природе на момент написания класса Car
мы даже возможно еще не начинали писать класс Driver**, но у нас есть ТЗ и в ТЗ сказано:

у объектов класса Driver должнен быть аттрибут “имя”
и вторым пунктом ТЗ: “Может возвращать имя”
именно поэтому мы и используем в блоке итератора вызов driver.name

=end

class Car
  attr_accessor :color
  attr_reader :drivers, :number

  def initialize(number)
    @number = number
    @color = "White"
    @drivers = []
  end

  def beep
    puts 'beep! beep!'
  end

  def add_driver(drive)
    @drivers << drive
  end

  def show_drivers
    @drivers.each { |driver| puts driver.name }
  end
end

class Driver
  attr_reader :name

  def initialize(name)
    @name = name
  end
end

# в этом коде реализованы пункты: “Имеет имя, которое указывается при создании” и “Может возвращать имя”

driver1 = Driver.new 'Denis'
puts driver1.name
driver2 = Driver.new 'Sveta'
puts driver2.name

car1 = Car.new(101)
p car1
car1.beep
puts car1.color
p car1.drivers
car1.add_driver(driver1)
p car1.drivers
car1.add_driver(driver2)
car1.show_drivers
