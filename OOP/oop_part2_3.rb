# even more interactions

# но давайте вернемся к реальности ))) автомобили ничего не знают про своих владельцев!

=begin

изменим ТЗ так, чтобы переложить бремя знания с автомобиля, на водителя

класс Автомобиль:

“Имеет номер, который указывается при создании”
“Может возвращать номер”
“Может иметь на двери надпись”
“Может устанавливать надпись на двери в значение равное имени владельца”
“Может возвращать надпись на двери”
“Имеет цвет, при создании цвет устанавливается в значение ‘white’”
“Может возвращать цвет, может менять цвет”
“Может выводить в консоли ‘beep beep’”
класс Водитель

“Имеет имя, которое указывается при создании”
“Может возвращать имя”
“Может покупать и владеть автомобилями”
“При покупке нового автомобиля наносит на его дверь свое имя”
“Может возвращать список автомобилей, которыми владеет”
мы убрали из класса Автомобиль все пункты, связанные со знаниями о водителях, и добавили автомобилю необязательный аттрибут 
“надпись на двери”…
“может устанавливать”, “может возвращать” очевидно озаначают необходимость добавить соотвествующие методы

=end

class Car
  attr_accessor :color
  attr_reader :door_title, :number

  def initialize(number)
    @number = number
    @color = 'white'
  end

  def beep
    puts 'beep! beep!'
  end

  def change_door_title(driver)
    @door_title = driver.name if driver.cars.include?(self)
  end
end

=begin

в методе change_door_title мы учли требование пункта “Может устанавливать надпись на двери в значение равное имени владельца”
благодаря проверке, касающейся “владения автомобилем”, надпись на двери изменится тогда и только тогда, когда переданный 
в метод объект (водитель) является владельцем текущего авто (внутри метода переменная self ссылается на объект класса Car, 
  у которого этот метод был вызван)
другими словами:
автомобиль у которого вызван метод change_door_title должен находится в списке @cars у водителя, имя которого мы хотим 
нанести на дверь

что может означать следующий пункт в классе Водитель: “Может покупать и владеть автомобилями” ?
он должен означать, что объект класса Driver, видимо должен хранить инстанс-переменную @cars (“владеть автомобилями”) 
и в классе должен быть метод buy_car, который будет добавлять автомобили в список автомобилей, которыми “владеет водитель”
здесь нужно обратить внимание на то, что в списке, т.е. в переменной, которая хранит в себе коллекцию (массив в нашем случае),
должны храниться не номера автомобилей, а объекты класса Car (точнее ссылки на эти объекты)

как легко догадаться строчка “Может возвращать список автомобилей, которыми владеет” должна означать необходимость геттера
для переменной @cars

1 - теперь посмотрим на фразу “При покупке нового автомобиля наносит на его дверь свое имя”… она должна означать, 
что в методе buy_car (в классе Driver) объект класса Car, переданный в метод, должен быть изменен
а именно, должно измениться содержание инстанс-переменной @door_title
для этого у нас в классе Car есть метод change_door_title
получается, что метод buy_car нужно дополнить. 
но откуда возьмется переменная driver ?
можно конечно передать объект в аргументах, вот так: driver.buy_car(car, driver)
однако такое решение будет хоть и работающим, но не верным
вспомним, что при вызове вида driver.buy_car(car) внутри метода buy_car на объект driver 
(тот самый у которого вызван метод)
ссылается переменная self
=end

class Driver
  attr_reader :name, :cars

  def initialize(name)
    @name = name
    @cars = []
  end

  def buy_car(car)
    @cars << car
    car.change_door_title(self) # Сноска 1 выше | self - вместо drive
  end
end

# Испытаем:

car1 = Car.new 101
p car1
car2 = Car.new 222
p car2

denis = Driver.new 'Denis'
p denis
olga = Driver.new 'Olga'
p olga

# проверяем надпись у первого авто и список авто у Denis

p car1.door_title
p denis.cars

# надписи нет, автомобилей тоже ) Denis покупает первый автомобиль и на двери авто появляется его имя

p denis.buy_car(car1)
p denis.cars

# пытаемся изменить надпись на двери автомобиля
p car1.change_door_title(olga)
p car1.door_title

# безуспешно - надпись не поменялась, потому что Olga не является владельцем автомобиля car1

# Olga покупает авто car2

p olga.cars
p car2.door_title
olga.buy_car(car2)
p olga.cars
p car2.door_title
